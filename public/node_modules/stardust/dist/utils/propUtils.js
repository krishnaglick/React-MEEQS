'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useAlignedProp = exports.useKeyOrValueAndKey = exports.useValueAndKey = exports.useKeyOnly = exports.imagePropRenderer = exports.iconPropRenderer = exports.getUnhandledProps = exports.customPropTypes = undefined;

var _isObject2 = require('lodash/isObject');

var _isObject3 = _interopRequireDefault(_isObject2);

var _isString2 = require('lodash/isString');

var _isString3 = _interopRequireDefault(_isString2);

var _omit2 = require('lodash/omit');

var _omit3 = _interopRequireDefault(_omit2);

var _keys2 = require('lodash/keys');

var _keys3 = _interopRequireDefault(_keys2);

var _union2 = require('lodash/union');

var _union3 = _interopRequireDefault(_union2);

var _find2 = require('lodash/find');

var _find3 = _interopRequireDefault(_find2);

var _isUndefined2 = require('lodash/isUndefined');

var _isUndefined3 = _interopRequireDefault(_isUndefined2);

var _some2 = require('lodash/some');

var _some3 = _interopRequireDefault(_some2);

var _isFunction2 = require('lodash/isFunction');

var _isFunction3 = _interopRequireDefault(_isFunction2);

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _has2 = require('lodash/has');

var _has3 = _interopRequireDefault(_has2);

var _isEmpty2 = require('lodash/isEmpty');

var _isEmpty3 = _interopRequireDefault(_isEmpty2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _includes2 = require('lodash/includes');

var _includes3 = _interopRequireDefault(_includes2);

var _compact2 = require('lodash/compact');

var _compact3 = _interopRequireDefault(_compact2);

var _isArray2 = require('lodash/isArray');

var _isArray3 = _interopRequireDefault(_isArray2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _templateObject = _taggedTemplateLiteral([' See ', ' prop `', '`.'], [' See ', ' prop \\`', '\\`.']);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _Icon = require('../elements/Icon/Icon');

var _Icon2 = _interopRequireDefault(_Icon);

var _Image = require('../elements/Image/Image');

var _Image2 = _interopRequireDefault(_Image);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

// ===============================================================
// Custom PropTypes
// ===============================================================
var type = function type() {
  var _Object$prototype$toS;

  return (_Object$prototype$toS = Object.prototype.toString).call.apply(_Object$prototype$toS, arguments);
};

var customPropTypes = exports.customPropTypes = {
  /**
   * Ensures children are of a set of types. Matches are made against the component _meta.name property.
   * @param {String[]} allowedTypes Collection of allowed component types.
   */
  ofComponentTypes: function ofComponentTypes(allowedTypes) {
    return function (props, propName, componentName) {
      if (propName !== 'children') {
        throw new Error('ofComponentTypes can only be used on the `children` prop, not ' + propName + '.');
      }
      if (!(0, _isArray3.default)(allowedTypes)) {
        throw new Error(['Invalid argument supplied to ofComponentTypes, expected an instance of array.'(_templateObject, componentName, propName)].join(''));
      }
      var disallowed = (0, _compact3.default)(_react.Children.map(props.children, function (child) {
        return (0, _includes3.default)(allowedTypes, (0, _get3.default)(child, 'type._meta.name')) ? null : child;
      }));
      if (!(0, _isEmpty3.default)(disallowed)) {
        return new Error('`' + componentName + '` should only have children of type `' + allowedTypes + '`.');
      }
    };
  },

  /**
   * Verifies exclusivity of a given prop.
   * @param {string[]} exclusives An array of props that cannot be used with this prop.
   */
  mutuallyExclusive: function mutuallyExclusive(exclusives) {
    return function (props, propName, componentName) {
      if (!(0, _isArray3.default)(exclusives)) {
        throw new Error(['Invalid argument supplied to mutuallyExclusive, expected an instance of array.'(_templateObject, componentName, propName)].join(''));
      }

      // mutually exclusive
      var disallowed = exclusives.reduce(function (acc, exclusive) {
        if ((0, _has3.default)(props, propName) && (0, _has3.default)(props, exclusive)) {
          return [].concat(_toConsumableArray(acc), [exclusive]);
        }
        return acc;
      }, []);

      if (!(0, _isEmpty3.default)(disallowed)) {
        return new Error(['`' + componentName + '` prop `' + propName + '` conflicts with props: `' + disallowed.join('`, `') + '`.', 'They cannot be defined together, choose one or the other.'].join(' '));
      }
    };
  },

  /**
   * Ensure a prop adherers to multiple prop type validators.
   * @param {function[]} validators An array of propType functions.
   */
  all: function all(validators) {
    return function (props, propName, componentName) {
      if (!(0, _isArray3.default)(validators)) {
        throw new Error(['Invalid argument supplied to all, expected an instance of array.', 'See ' + componentName + ' prop `' + propName + '`.'].join(' '));
      }

      var errors = (0, _compact3.default)((0, _map3.default)(validators, function (validator) {
        if (!(0, _isFunction3.default)(validator)) {
          throw new Error('all() argument "validators" should contain functions, found: ' + type(validator) + '.');
        }
        return validator(props, propName, componentName);
      }));

      // we can only return one error at a time
      return errors[0];
    };
  },

  /**
   * Ensure a prop adherers to at least one of the given prop type validators.
   * @param {function[]} validators An array of propType functions.
   */
  any: function any(validators) {
    return function (props, propName, componentName) {
      if (!(0, _isArray3.default)(validators)) {
        throw new Error(['Invalid argument supplied to all, expected an instance of array.', 'See ' + componentName + ' prop `' + propName + '`.'].join(' '));
      }

      var errors = (0, _map3.default)(validators, function (validator) {
        if (!(0, _isFunction3.default)(validator)) {
          throw new Error('any() argument "validators" should contain functions, found: ' + type(validator) + '.');
        }
        return validator(props, propName, componentName);
      });

      // if no validator returned undefined (no error)
      // return the first error found
      if (!(0, _some3.default)(errors, _isUndefined3.default)) {
        return (0, _find3.default)(errors, function (error) {
          return !(0, _isUndefined3.default)(error);
        });
      }
    };
  },

  /**
   * Define prop dependencies by requiring other props.
   * @param {string[]} requiredProps An array of required prop names.
   */
  require: function require(requiredProps) {
    return function (props, propName, componentName) {
      if (!(0, _isArray3.default)(requiredProps)) {
        throw new Error(['Invalid `requiredProps` argument supplied to require, expected an instance of array.'(_templateObject, componentName, propName)].join(''));
      }

      // do not require requiredProps if the prop does not exist in props
      if (!(0, _has3.default)(props, propName)) return;

      var missingRequired = requiredProps.filter(function (required) {
        return !(0, _has3.default)(props, required);
      });
      if (!(0, _isEmpty3.default)(missingRequired)) {
        return new Error('`' + componentName + '` prop `' + propName + '` requires props: `' + missingRequired.join('`, `') + '`.');
      }
    };
  }
};

// ===============================================================
// Instance Utils
// ===============================================================
/**
 * Returns an object consisting of props beyond the scope of the Component.
 * Useful for getting and spreading unknown props from the user.
 * @param {*} Component A React.Component.
 * @param {*} props Props from a React.Component instance.
 * @returns {{}} A shallow copy of the prop object
 */
var getUnhandledProps = exports.getUnhandledProps = function getUnhandledProps(Component, props) {
  var handledProps = (0, _union3.default)(Component.autoControlledProps, (0, _keys3.default)(Component.defaultProps), (0, _keys3.default)(Component.propTypes));

  return (0, _omit3.default)(props, handledProps);
};

// ----------------------------------------
// Prop Renderers
//
// Many components share many props. Some of those props should be smart.
// These give all our components props consistent smart capabilities.
// ----------------------------------------
var iconPropRenderer = exports.iconPropRenderer = function iconPropRenderer(val) {
  var props = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  if ((0, _isString3.default)(val)) return _react2.default.createElement(_Icon2.default, _extends({}, props, { name: val }));

  if ((0, _isObject3.default)(val)) {
    var className = (0, _classnames2.default)(val.props.className, props.className); // eslint-disable-line
    return _react2.default.cloneElement(val, _extends({}, val.props, props, { className: className }));
  }
};

var imagePropRenderer = exports.imagePropRenderer = function imagePropRenderer(val) {
  var props = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  if ((0, _isString3.default)(val)) return _react2.default.createElement(_Image2.default, _extends({}, props, { src: val }));

  if ((0, _isObject3.default)(val)) {
    var className = (0, _classnames2.default)(val.props.className, props.className); // eslint-disable-line
    return _react2.default.cloneElement(val, _extends({}, val.props, props, { className: className }));
  }
};

// ----------------------------------------
// Prop to className
//
// There are 4 prop patterns used to build up the className for a component.
// Each utility here is meant for use in a classnames() argument.
//
// There is no util for valueOnly() because it would simply return val.
// Use the prop value inline instead.
//   <Label size='big' />
//   <div class="ui big label"></div>
// ----------------------------------------

/**
 * Props where only the prop key is used in the className.
 * @param {*} val A props value
 * @param {string} key A props key
 *
 * @example
 * <Label tag />
 * <div class="ui tag label"></div>
 */
var useKeyOnly = exports.useKeyOnly = function useKeyOnly(val, key) {
  return val && key;
};

/**
 * Props that require both a key and value to create a className.
 * @param {*} val A props value
 * @param {string} key A props key
 *
 * @example
 * <Label corner='left' />
 * <div class="ui left corner label"></div>
 */
var useValueAndKey = exports.useValueAndKey = function useValueAndKey(val, key) {
  return val && val !== true && val + ' ' + key;
};

/**
 * Props whose key will be used in className, or value and key.
 * @param {*} val A props value
 * @param {string} key A props key
 *
 * @example Key Only
 * <Label pointing />
 * <div class="ui pointing label"></div>
 *
 * @example Key and Value
 * <Label pointing='left' />
 * <div class="ui left pointing label"></div>
 */
var useKeyOrValueAndKey = exports.useKeyOrValueAndKey = function useKeyOrValueAndKey(val, key) {
  return val && (val === true ? key : val + ' ' + key);
};

//
// Prop to className exceptions
//

/**
 * The "aligned" prop follows the useValueAndKey except when the value is "justified'.
 * In this case, only the class "justified" is used, ignoring the "aligned" class.
 * @param {*} val The value of the "aligned" prop
 *
 * @example
 * <Container aligned='justified' />
 * <div class="ui justified container"></div>
 *
 * @example
 * <Container aligned='left' />
 * <div class="ui left aligned container"></div>
 */
var useAlignedProp = exports.useAlignedProp = function useAlignedProp(val) {
  return val === 'justified' ? 'justified' : useValueAndKey(val, 'aligned');
};